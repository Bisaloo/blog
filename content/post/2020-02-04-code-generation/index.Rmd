---
slug: code-generation
title: "Code generation in R packages"
authors:
  - Maëlle Salmon
date: "2020-02-04"
tags:
- package development
output: 
  html_document:
    keep_md: true
---

If you use the [same code three times](https://en.wikipedia.org/wiki/Rule_of_three_(computer_programming)), write a function. If you write three such related functions, set up a package. But if you write three embarrassingly similar functions... write code to generate their code for you? In this post, we'll deal with source code generation. We'll differentiate scaffolding from generating code, and we'll present various strategies observed in the wild.

_This post was inspired by an [excellent Twitter thread started by Miles McBain](https://twitter.com/MilesMcBain/status/1199451518090395649), from which we gathered examples. Thank you Miles!_

## Introduction

### If you can repeat yourself, you're lucky

When would you need to generate code with code? A possible use case is web API with many, many endpoints that have a predictable structure (parameters, output format) that's well documented ("API specs").

In any case, to be able to generate code, you'll have some sort of underlying data/ontology. Having that data (specs of a web API, of an external tool you're wrapping, list of all your ideas, etc.), and some consistency in the different items, is quite cool, lucky you! Some of us deal with less tidy web APIs. :wink:

### Scope of this post 

In this post, we'll look into _scaffolding_ code (when your output is some sort of skeleton that's still need some human action before being integrated in a package) and _generating_ code (you hit a button and end up with more functions and docs in the package for its users to find). We won't look into packages exporting [function factories](adv-r.hadley.nz/function-factories.html).

## Scaffolding code

> "There was no way I was writing 146 functions from scratch". Bob Rudis, [GitHub comment](https://github.com/rstudio/swagger/issues/1#issuecomment-395627756).

Even without getting to the dream situation of code being cleanly generated, it can help your workflow to create function skeletons based on data.

* The [quote by Bob Rudis above](https://github.com/rstudio/swagger/issues/1#issuecomment-395627756) refers to his work on [`crumpets`](https://github.com/hrbrmstr/crumpets/) where he used the [Swagger](https://en.wikipedia.org/wiki/Swagger_(software)) spec of the Gitea API to generate drafts of many, many functions. The idea was to have following commits edit functions enough to make them work without, as he said, starting from scratch.

* When dealing with a less consistent web API, e.g. the [Hubspot API](https://developers.hubspot.com/docs/overview), a one-off webscraping of the docs can help list endpoints to be implemented and, say, open [tickets in a issue tracker](https://github.com/lockedata/hubspot/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3A%22New+endpoint+%3Around_pushpin%3A%22) with some skeletons in them. One could use [the `projmgr` package by Emily Riederer](https://emilyriederer.github.io/projmgr/index.html) in such a context to open issues/list of tasks.

## Generating code

> "odin works using code generation; the nice thing about this approach is that it never gets bored. So if the generated code has lots of tedious repetitive bits, they're at least likely to be correct (compared with implementing yourself)." Rich FitzJohn, [odin README](https://mrc-ide.github.io/odin/articles/odin.html).

Quite convincing, right? But _how_ does one generate code for an R package? The first question is _when_ does one generate code.

### Generating code once or once in a while

* For the package whose development prompted him to start the Twitter thread mentioned earlier, Miles McBain used code generation. The package creates wrappers around `dplyr` functions, that can in particular automatically `ungroup()` your data. Now say Miles decides to wrap a further `dplyr` function. 
    * He updates the [list of wrappers](https://github.com/MilesMcBain/wisegroup/blob/master/group_aware_functions.R)
    * He can then [run a make.R script](https://github.com/MilesMcBain/wisegroup/blob/master/make.R) that will [source a build.R script](https://github.com/MilesMcBain/wisegroup/blob/master/build.R) that creates R files with actual R code and lines with `roxygen2` code, before running `devtools::document()`.
    
Code generating a function

```r

build_fn <- function(fn) {

  fn_name <- name(fn)

  glue::glue("{fn_name} <- function(...) {{\n",
             "  dplyr::ungroup(\n",
             "    {fn}(...)\n",
             "  )\n",
             "}}\n")

}
```

Code generating docs

```r
build_fn_doco <- function(fn) {

  fn_name <- name(fn)

  glue::glue(
    "##' Ungrouping wrapper for {fn_name}\n",
    "##'\n",
    "##' The {PKGNAME} package provides a wrapper for {fn_name} that always returns\n",
    "##' ungrouped data. This avoids mistakes associated with forgetting to call ungroup().\n",
    "##'\n",
    "##' For original documentation see [{fn}()].\n",
    "##'\n",
    "##' Use [{fn_name}...()] to retain groups as per `{fn}`, whilst\n",
    "##' signalling this in your code.\n",
    "##'\n",
    "##' @title {fn_name}\n",
    "##' @param ... parameters for {fn}\n",
    "##' @return an ungrouped dataframe\n",
    "##' @author Miles McBain\n",
    "##' @export\n",
    "##' @seealso {fn}, {fn_name}..."
  )

}

```

    
Voilà, there's an updated `R/` folder, `man/` folder and `NAMESPACE`, and it all works.
    
* A similar setup is used by Carl Boettiger in [`eml.build` for generating functions based on an XML spec](https://github.com/cboettig/build.eml/blob/master/data-raw/create-functions.R). [Tweet](https://twitter.com/cboettig/status/1199489890527805440).

* A further example is [`redux` by Rich FitzJohn](https://github.com/richfitz/redux/blob/master/extra/generate.R) where code is generated based on [Redis docs](https://github.com/antirez/redis-doc). [Tweet](https://twitter.com/rgfitzjohn/status/1199467409301749762).

* Last example for this post, `xaringanthemer` by Garrick Aden-Buie [generates functions](https://github.com/gadenbuie/xaringanthemer/blob/master/inst/scripts/generate_theme_functions.R) based [on a `tibble`](https://github.com/gadenbuie/xaringanthemer/blob/master/R/theme_settings.R) containg "Function arguments, doc strings and theme-specific defaults " that's also used to generate [a docs page](https://pkg.garrickadenbuie.com/xaringanthemer/articles/template-variables.html). [Tweet](https://twitter.com/grrrck/status/1199483617770115073).
    
### Generating code at installation

### Generating code on-the-fly

chromote

generating code based on a specification given by an user [like what `odin` does for IDE](https://mrc-ide.github.io/odin/articles/odin.html).

Easy to get out of scope here.

## Conclusion

In this post we explored different aspects of source code scaffolding and generation in R packages. In the more general context of [automatic programming](https://en.wikipedia.org/wiki/Automatic_programming), one also finds "generative programming", and "low-code applications" (like [tidyblocks](https://tidyblocks.tech/)?). As much as one enjoys writing R code, it's great to be able to write less of it sometimes. 

Do _you_ use source code generation in R? Don't hesitate to add your own use case and setup in the comments below.